# Структуры данных

## Массивы

**Массив** -  структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов, принимающих целые (или приводимые к целым) значения из некоторого заданного непрерывного диапазона.

> Массивы могут быть многомерными. То есть каждый элемент массива может содержать в себе другой массив.

> Массив относится к структурам данных с *произвольным доступом*.

### Плюсы

+ Мгновенный доступ к элементам в произвольных позициях (O(1))

### Минусы

- Медленная вставка элементов, требует перемещения всех элементов на новую память (O(n))
- Медленное удаление, требует сдвига элементов O(n)

## Списки

**Свя́зный спи́сок** — базовая динамическая структура данных, состоящая из узлов,
каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка.

> Связаный список относится к структурам данных с *последовательным доступом*.

### Плюсы

+ Быстрая вставка нового элемента (O(1))
+ Быстрое удаление элементов O(1)

### Минусы

- Долгий доступ к элементам в произвольных позициях O(n)

## Стэк

**Стэк** - структура данных работающая по принципу *Первым вошёл, последним вышел* (FILO).

То есть элементы структуры заполнятся один над другим и можно получить доступ только
к элементу который на момент обращения находится на верху, то есть последнему добавленному.
Чтобы получить доступ к элементу снизу надо вначале извлеч все элементы
находящиеся сверху него.

Аналогия это стакан с зерном, чтобы достать зёрна которые лежат внизу стакана необходимо вначале высыпать всё зёрна которые находятся срерху.

> Пример: стэк вызовов.

> Стэк относится к структурам данных с *последовательным доступом*.

### Плюсы

+ Мгновенный доступ к элементу на вершине стэка O(1)
+ Простора реализации, поддерживает только две функции: занесение и извлечение элемента.

### Минусы

- Нет доступа к произвольным элементам


### Хэш-таблица

**Хэш-функция** - это функция которая преобразует входной массив данных произвольной длинны в уникальную последовательность бит фиксированного размера.

**Хэш-таблица(словарь, хэш, hash-map)** - структура данных которая связывает ключ со значением посредством хэш-функции.

Применение:
1. Моделирование отношений между объектами
1. Устранение дубликатов
1. Кеширование

Быстродействие хэш фкнкций:
поиск, вставка, удаление:
- средний случай - `O(1)`,
- худший случай - `O(n)`.

## Очредь - Queue

Очередь - структура данных работающая по принципу **Превым вошёл, первым вышел** (FIFO).

Элементы добавляются в конец очереди, полседовательно один за другим, извлечение происходит с
начала очереди.

> Очередь относится к структурам данных с *последовательным доступом*.
> Пример: Список поиска для алгоритма поиск в ширину.

### Плюсы

+ Мгновенный доступ к первому элементу очереди.
+ Простора реализации, поддерживает только две функции: занесение и извлесение элемента.

### Минусы

- Нет доступа к произвольным элементам.

## Граф

**Граф** - структура данных которая моделирует связи между своими элементами.

Графы бывают **напраленными**(->) и **ненаправленными** (--).

**Направленный граф** - это граф в котором ребро (связь) является однонаправленной от одного узла к другому узлу и отображается стрелкой.
Пример: (Узел А)------->(Узел Б)
В этом примере узел Б является связью(соседом) для узла А, но узел А не является связью для узла Б.

В **ненапрвленном графе** любые соседние узлы являются связью(соседями) друг для друга.
Пример: (Узел А)--------(Узел Б)
В этом примере узел Б является связью для узла А, а узел А является связью для узла Б.

**Дерево** - граф в котором отсутствуют ребра в обратном направлении,
т.е все ребра имеют одно направление.

> Граф можно реалтзовать с помощью хеш-таблицы(unordered_map).

Графы бывают **взвешенными**(-n-) и **невзвешенными** (--). Где n это вес.

У **взвешенного графа** для каждого ребра устанавливается число называемое весом.

## Множество. unordered_set (c++), set (python).

**Множество** - структура данных основаннная на *хэш-таблицах* которая позволяет выполнять математические операции над мнодествами такие как: *объединение, пересечение, разность*.

## Динамическое программирование

*Динамическое программирование работает только в том случае, если каждая подзадача автономна, то есть не зависит от других подзадач.*

*Динамическое программирование применяется для оптимизации какой-либо характеристики при заданных ограничениях.*

### Рекомендации для решения задач с использованием динамического программирования

- в каждом решении из области динамического программирования строится таблица;
- значение ячеек таблицы обычно соответствует оптиизируемой характеристике. Например стоимость в задаче о рюкзаке.
- каждая ячейка представляет подзадачу, поэтому вы должны подумать о том, как разбить задачу на подзадачи.

### Где используется динамическое программирование:

- команда `diff` в `git`;
- *Растояние Левенштейна* - на сколько похожи две строки, проверка орфографии;
- перенос строк в *Microsoft Word*

### Нахождение самой длинной общей подстроки

Допустим пользователь ввёл `hish`, какое слово он имел ввиду `fish` или `vista`?

Алгоритм:
- если буква не совпадает значение 0
- если совпадает то значение равно значению наверху слева + 1

Таблица для fish:

|   | H | I | S | H |
|---|---|---|---|---|
| F | 0 | 0 | 0 | 0 |
| I | 0 | 1 | 0 | 0 |
| S | 0 | 0 | 2 | 0 |
| H | 0 | 0 | 0 | **3** |

Самая длинная общая подстрока для `hish` и `fish` = 3.

Таблица для vista:

|   | H | I | S | H |
|---|---|---|---|---|
| V | 0 | 0 | 0 | 0 |
| I | 0 | 1 | 0 | 0 |
| S | 0 | 0 | **2** | 0 |
| T | 0 | 0 | 0 | 0 |
| A | 0 | 0 | 0 | 0 |

Самая длинная общая подстрока для `hish` и `vista` = 2.

Получется `fish` больше подходит чем `vista` так как имеет более блинную общую подстроку с `hish`.

Псевдокод:
```python
if word_a[i] == word_b[j]:
    cell[i][j] = cell[i-1][j-1] + 1
else:
    cell[i][j] = 0
```

### Самая длинная общая последовательность

Допустим пользователь ввёл `fosh`, какое слово он имел ввиду `fish` или `fort`?

Алгоритм:
- если буква не совпадает выбрать большее значение
- если совпадает то значение равно значению наверху слева + 1

Таблица для fish:

|   | F | O | S | H |
|---|---|---|---|---|
| F | 1 | 1 | 1 | 1 |
| I | 1 | 1 | 1 | 1 |
| S | 1 | 1 | 2 | 2 |
| H | 1 | 1 | 1 | **3** |

Самая длинная общая поледовательнось для `fosh` и `fish` = 3.

Таблица для fort:

|   | F | O | S | H |
|---|---|---|---|---|
| F | 1 | 1 | 1 | 1 |
| O | 1 | 2 | 2 | 2 |
| R | 1 | 2 | 2 | 2 |
| T | 1 | 2 | 2 | **2** |

Самая длинная общая поледовательнось для `fosh` и `fort` = 2.

Плучается `fish` больше подходит так как имеет большую общую последовательность, чем `fort`.

Псевдокод:
```python
if word_a[i] == word_b[j]:
    cell[i][j] = cell[i-1][j-1] + 1
else:
    cell[i][j] = max(cell[i-1][j], cell[i][j-1])
```