# **Грокаем алгоритмы**

## **О-большое**

> **О-большое** описывает на сколько быстро работает алгоритм.

> Записывается как `O(n)`, где `n` число операций.

> **О-большое** определяет количество операций в *худшем случае*.

Основные примеры О-большого:

+ `O(log n)` - логарифмическое время. Пример: бинарный поиск.
+ `O(n)` - линейное время. Пример: Простой поиск.
+ `O(n * log n)` - Пример: эффективные алгоритмы сортировки.
+ `O(n * n)` - Пример: медленные алгоритмы сортировки (сортировка выбором).
+ `O(n!)` - Пример: очень медленные алгоритмы (задача о комивояжоре).

По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.

> Время выполнения алгоритмов описывается *ростом* количества операций.

## Алгоритмы поиска

### Бинарный поиск (Binary search)

**Время выполнения: `O(log n)` **

Бинарный поиск сокращает количество элементов входного массива в два раза на каждой итерации.

> Бинарный поиск работает только с отсортированными массивами.

Пример: Дан массив: [2, 1, 5, 4, 8], необходимо найти индекс элемента со значением = 1.

нижний элемент = 0
верхний элемент = 4

средний элемент = (нижний элемент + верхний элемент) / 2 = (0 + 4) / 2 = 2

если средний элемент == заданному значению то возвращаяем индекс среднего элемента.
Иначе проверяем если средний элемент > искомого, то верхний элемент = средний элемент(2) - 1 = 1,
иначе нижний элемент равен средний элемент(2) + 1 = 3. На последующих итерациях делаем тоже самое
пока не будет найден нужный элемент или возвращаем код ошибки.

## Алгоритмы сортировки

### Сортировка выбором (Selection Sort)

Сортировка выбором заключается в выборе наименьшего элемента из входного массива,
добавления его в новый массив и удаление его же из входного массива.

**Время выполнения: `O(n * n)` **

Пример: Дан не отсортированный массив: [2, 1, 5, 4].

| Входной массив | Отсортированный массив |
|-----------------------------------------|
| [2, 1, 5, 4]   |[]                      |
| [2, 5, 4]      |[1]                     |
| [5, 4]         |[1, 2]                  |
| [5]            |[1, 2, 4]               |
| []             |[1, 2, 4, 5]            |

### Быстрая сортировка (Quick sort)

**Время выполнения: `O(n * log n)` **

Быстрая сортировка это рекурсивный алгоритм основанный на принципе *******разделяй и властвуй**.

Стратегия **разделяй и властвуй** основана на разбиении задачи на уменьшающиеся фрагменты.

Базовый случай алгоритма: когда массив пуст или состоит из одного элемента. Возможно добавить как базовый случай еще и массив с 2мя элементами.

Рекурсивный случай: когда элементов массива больше 1го.

Вначале выбирается опорный элемент из входного массива, например средний элемент или случайный элемент. Затем входной массив разделяется на два подмассива первый с элементами меньше чем опорный элемент, а второй с элементами больше чем опорный элемент. Вызов алгоритма выполняется рукурсивно для каждого подмассива пока не будет достигнут базовый случай. Вконце возвращается массив состоящий из [подмасиив с элементами меньше опороного] <опорный элемент> [подмассив с элементами больше опорного].

Пример: Дан не отсортированный массив: [2, 1, 5, 4, 0].

Опормым будем брать средний элемент.
1 вызов для входного массива:
[2, 1, 4, 0] <5> []
2 вызов для подмассива с элементами < 5:
[0] <1> [2, 4]
3 вызов для подмассива > 1:
[] <2> [4]

3й вызов возвращает массив: [2, 4]
2й вызов возвращает массив: [0, 1, 2, 4]
1й вызов возвращает массив: [0, 1, 2, 4, 5]

## Алгоритмы поиска для графов

### Поиск в ширину

Время выполения: `O(N+R)`, где:
- N - количество узлов (nodes)
- E - количество ребер (edges)

**Поиск в ширину** позволяет определить существует ли путь от узла А к узлу Б в графе,
если путь существует то находит кратчайший путь, т.е. такой путь в котором наименьшее 
количество сегментов.

Реализация:
- создаём список поиска используя двунаправленную очередь (deque)
- добаляем в очередь соседей корневого узла графа
- создаём список для проверенных узлов
- в цикле, пока очередь поиска не будет пустой:
- извлекаем из очереди поиска первый(очередной) узел
- проверяем что он еще не был проверен
- проверяем не удовлетворяет ли узел условиям поиска
- елси узел удовлетворяет условиям поиска, то возвращаем результат
- иначе добавляем соседей узла в список поиска
- добавляем узел в список проверенных узлов
- переходим к следующей итерации цикла...

### Алгоритм Дейкстры

> Алгоритм **Дейкстры** работает только с *направленными ациклическими взвешенными графами* 
Direct Acyclic Graph (DAG), в которых нет ребер с отрицательными весами.

> Для вычисления кратчайшего пути во взвешенном направленном графе, содержащем отрицательные 
веса ребер необходимо воспользоваться алгоритмом **Беллмана-Форда**.

Алгоритм:

1. Найти узел с наименьшим весом
1. Проверить, существует ли путь имеющий меньший вес к соседям этого узла, если существует,
обновить их стоимости
1. Повторять, это для всех узлов графа
1. Вычислить итоговый путь

