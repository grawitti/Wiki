# **Грокаем алгоритмы**

## **О-большое**

**О-большое** определяет количество операций в *худшем случае*.

> Записывается как `O(n)`, где `n` число операций.

Основные примеры О-большого:

+ `O(log n)` - логарифмическое время. Пример: бинарный поиск.
+ `O(n)` - линейное время. Пример: Простой поиск.
+ `O(n * log n)` - Пример: эффективные алгоритмы сортировки.
+ `O(n * n)` - Пример: медленные алгоритмы сортировки (сортировка выбором).
+ `O(n!)` - Пример: очень медленные алгоритмы (задача о комивояжоре).

По сути формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.

## Алгоритмы поиска

### Бинарный поиск (Binary search)

**Время выполнения**: `O(log n)`

Бинарный поиск агоритм поиска в отсортированном массиве, при каждой итерации размер массива сокращается в два раза.

> Бинарный поиск работает только с отсортированными массивами.

Пример: Дан массив: [2, 1, 5, 4, 8], необходимо найти индекс элемента со значением = 1.

нижний элемент = 0
верхний элемент = 4

средний элемент = (нижний элемент + верхний элемент) / 2 = (0 + 4) / 2 = 2

если средний элемент == заданному значению то возвращаяем индекс среднего элемента.
Иначе проверяем если средний элемент > искомого, то верхний элемент = средний элемент(2) - 1 = 1,
иначе нижний элемент равен средний элемент(2) + 1 = 3. На последующих итерациях делаем тоже самое
пока не будет найден нужный элемент или возвращаем код ошибки.

## Алгоритмы сортировки

### Сортировка выбором (Selection Sort)

Сортировка выбором заключается в выборе наименьшего/наибольшего элемента из входного массива,
добавления его в новый массив и удаление его же из входного массива.

**Время выполнения**: `O(n * n)`

Пример: Дан не отсортированный массив: [2, 1, 5, 4].

| Входной массив | Отсортированный массив |
|-----------------------------------------|
| [2, 1, 5, 4]   |[]                      |
| [2, 5, 4]      |[1]                     |
| [5, 4]         |[1, 2]                  |
| [5]            |[1, 2, 4]               |
| []             |[1, 2, 4, 5]            |

### Быстрая сортировка (Quick sort)

**Время выполнения**: `O(n * log n)`

Быстрая сортировка это рекурсивный алгоритм основанный на принципе **разделяй и властвуй**.

Стратегия **разделяй и властвуй** основана на разбиении задачи на уменьшающиеся фрагменты.

Решение задач методом **разделяй и властвуй** состоит из двух шагов:
- определить базовый случай, простейший случай из всех вохможных,
- задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.

Базовый случай алгоритма: когда массив пуст или состоит из одного элемента. Возможно добавить как базовый случай еще и массив с 2мя элементами.

Рекурсивный случай: когда элементов массива больше 1го.

Вначале выбирается опорный элемент из входного массива, например средний элемент или случайный элемент. Затем входной массив разделяется на два подмассива первый с элементами меньше чем опорный элемент, а второй с элементами больше чем опорный элемент. Вызов алгоритма выполняется рукурсивно для каждого подмассива пока не будет достигнут базовый случай. Вконце возвращается массив состоящий из [подмасиив с элементами меньше опороного] <опорный элемент> [подмассив с элементами больше опорного].

Пример: Дан не отсортированный массив: [2, 1, 5, 4, 0].

Опормым будем брать средний элемент.
1 вызов для входного массива:
[2, 1, 4, 0] <5> []
2 вызов для подмассива с элементами < 5:
[0] <1> [2, 4]
3 вызов для подмассива > 1:
[] <2> [4]

3й вызов возвращает массив: [2, 4]
2й вызов возвращает массив: [0, 1, 2, 4]
1й вызов возвращает массив: [0, 1, 2, 4, 5]

## Алгоритмы поиска для графов

### Поиск в ширину

Время выполения: `O(N+R)`, где:
- N - количество узлов (nodes)
- E - количество ребер (edges)

**Поиск в ширину** позволяет определить существует ли путь от узла А к узлу Б в графе,
если путь существует то находит кратчайший путь, т.е. такой путь в котором наименьшее 
количество сегментов.

Реализация:
- создаём список поиска используя двунаправленную очередь (deque)
- добаляем в очередь соседей корневого узла графа
- создаём список для проверенных узлов
- в цикле, пока очередь поиска не будет пустой:
- извлекаем из очереди поиска первый(очередной) узел
- проверяем что он еще не был проверен
- проверяем не удовлетворяет ли узел условиям поиска
- елси узел удовлетворяет условиям поиска, то возвращаем результат
- иначе добавляем соседей узла в список поиска
- добавляем узел в список проверенных узлов
- переходим к следующей итерации цикла...

### Алгоритм Дейкстры

> Алгоритм **Дейкстры** работает только с *направленными ациклическими взвешенными графами* 
Direct Acyclic Graph (DAG), в которых нет ребер с отрицательными весами.

> Для вычисления кратчайшего пути во взвешенном направленном графе, содержащем отрицательные 
веса ребер необходимо воспользоваться алгоритмом **Беллмана-Форда**.

Алгоритм:

1. Найти узел с наименьшим весом
1. Проверить, существует ли путь имеющий меньший вес к соседям этого узла, если существует,
обновить их стоимости
1. Повторять, это для всех узлов графа
1. Вычислить итоговый путь

## Жадные алгоритмы

**Жадный алгоритм** (greedy algorithm) — это алгоритм, который на каждом шагу делает локально наилучший выбор в надежде, что итоговое решение будет оптимальным.

К примеру, *алгоритм Дейкстры* нахождения кратчайшего пути в графе вполне себе жадный, потому что мы на каждом шагу ищем вершину с наименьшим весом, в которой мы еще не бывали, после чего обновляем значения других вершин. При этом можно доказать, что кратчайшие пути, найденные в вершинах, являются оптимальными.

### NP-полные задачи

**NP-полные задачи** - класс задач для которых **НЕ** существуют «быстрые» алгоритмы решения (время работы которых полиномиально зависит от размера входных данных).

Такие задачи принято решать *приближенными алгоритмами*.

#### Признаки NP-полных задач

- ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа;

- формулировка "все комбинации Х" часто указывает на NP-полную задачу;

- вам приходится вычислять все возможные варианты Х, потому что задачу невозможно разбить на меньшие подзадачи;

- если в задаче встречается некоторая последовательность (например, последовательноть городов, как в задаче о комивояжоре) и задача не имеет простого решения;

- если в задаче встречается некоторое множество и задача не имеет простого решения;

- можно ли преформулировать задачу в условиях задачи покрытия множества или задачи о комивояжоре.

### Приближённые алгоритмы

**Приближенный алгоритм** - это *жадный алгоритм* для решения *NP-полных задач*, который на каждом шаге находит *оптимальное решение*, в расчёте на то что будет достигнут *глобальный оптумум*.
