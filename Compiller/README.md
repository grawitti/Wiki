# Компиляция и дебагинг

## Компилятор g++

**g++** - компилятор использует для компиляции коллекцию компиляторов **GCC**, но указывает дополнительные флаги и связывается со стандартной библиотекой C++.

>Вызов `g++` эквивалентен вызову `gcc -xc++ -lstdc++ -shared-libgcc`

**gcc** шаги при компиляции:

* **Препроцессирование**: Создание кода, более не содержащего директив. Вещи вроде «#if» не могут быть поняты компилятором, поэтому должны быть переведены в реальный код. Также на этой стадии разворачиваются макросы.

* **Компиляция**: Берется обработанный код, проводятся лексический и синтаксический анализы, и генерируется ассемблерный код. В течение этой фазы, gcc выдает сообщения об ошибках или предупреждениях в случае, если анализатор при парсинге вашего кода находит там какие-либо ошибки. Если запрашивается оптимизация, gcc продолжит анализировать ваш код в поисках улучшений и манипулировать с ними дальнейшем.

* **Ассемблирование**: Принимаются ассемблерные мнемоники и производятся объектные коды, содержащие коды команд. Часто недопонимают то, что на стадии компиляции не производятся коды команд, это делается на стадии ассемблирования. В результате получаются один или более объектных файла, содержащие коды команд, которые являются действительно машинозависимыми.

* **Компоновка**: Трансформирует объектные файлы в итоговые исполняемые. Одних только кодов операции недостаточно для того, чтобы операционная система распознала и выполнила их. Они должны быть встроены в более полную форму. Эта форма, известная как бинарный формат, указывает, как ОС загружает бинарный файл, компонует перемещение и делает другую необходимую работу. ELF является форматом по умолчанию для Linux на x86.

## Параметры gcc

### 1. Параметры, относящиеся к оптимизации кода

Опция `-O`. Она и ускоряет выполнение вашего кода, и сжимает размер итогового кода. У неё существует пять вариантов:

* от `-O0` (O ноль) до `-O3`. "0" означает отсутствие оптимизации, а "3" — наивысший уровень оптимизации. "1" и "2" находятся между этими краями. Если просто используете -O без указания номера, это будет означать -O1.

* `-Os` говорит gcc оптимизировать размер. В общем-то, это похоже на `-O2`, но пропускает несколько шагов, которые могут увеличить размер.

### 2. Опции, относящиеся к отладке

* Опция `-g` добавляет к объектному файлу регистры с отладочной информацией, необходимой для отладки с помощью `gdb` или `lldb`.
* `-DDEBUG` условная компиляция, не будет создано объектного файла, только выполнится проверка кода.

>Чтобы отладочная информация совпадала с исходным кодом необходимо не оспользовать оптимизацию, т.е. совмещать флаг `-g` с флагом `-O0`.

### 3. Опции, управляющие стадиями компиляции

* `-c` останавливает на стадии ассемблирования, но пропускает компоновку. Результатом является объектный код.

* `-E` останавливает на стадии препроцессинга. Все директивы препроцессора развернуты, так что вы видите только чистый код.

* `-S` останавливает после компиляции. Она оставляет вас с ассемблерным кодом.

`-c` наиболее часто используется, когда у вас есть несколько исходных файлов и вы хотите скомбинировать их для получения итогового исполняемого файла.

Так что, вместо такого:  
`gcc -o final-binary test1.c test2.c`  
будет лучше разделить их так:  
`gcc -c -o test1.o test1.c`  
`gcc -c -o test2.o test2.c`  
и затем:  
`gcc -o final-binary ./test1.o ./test1.o`  

>Возможно, вы заметили, что такая же последовательность используется, если вы собираете программу, используя Makefile. Преимущество использования `-c` ясно: вам нужно перекомпилировать только измененные исходные файлы. Только фаза, на которой переделывается компоновка всех объектных файлов, и это очень экономит время, особенно в больших проектах. Очевидным примером этого является ядро Linux.

### 4. Библиотеки

* `-Lpath_to_library` - опция указывает для компановщика путь `path_to_library`, в котором он будет искать библиотеки.

>`.` - текущий каталог. 
Пример: `-L.` - искать библиотеки в текущем каталоге.

* `-lимя_библиотеки.a` - указывает компановщику использовать библиотеку `имя_библиотеки.a`. 

### Вспомогательные инструменты:

1. Коллекция утилит ELF, которая включает в себя такие программы, как `objdump` и `readelf`. Они парсят для нас информацию о ELF.

    **Linux:**

    `readelf -S имя_объектного_файла.o`

    **Linux, MacOS:**

    `objdump -t имя_объектного_файла.o`

2. **ar** — стандартная утилита Unix, архиватор, не использующий сжатия данных.

>В настоящее время **ar** используется главным образом для создания и обновления статических библиотек, которые используются линковщиками, а для любых других целей вместо него обычно применяется tar.

### Использование: 
`ar [-]{dmpqrtx}[abcilosuvV] [имя_компонента_архива] архив-файлы…`

>**ar** может не только создавать/извлекать файлы из архива, но и модифицировать их.

### Параметры запуска:

* `r`	- вставляет файлы в архив (с замещением)
* `c`	- создать архив
* ...

Пример:

`ar rc имя_библиотеки.a имя_объектного_файла.o`  
создает статическую библиотеку `имя_библиотеки.a`  

