## Классы

### Правила реализации хороших классов:
* Если был захвачен ресурс **(new)** или какие-то члены класса **указаткли**, то должен быть **деструктор класса**.
* Если класс имеет **деструктор**, то скорее всего он должен иметь **копирующий конструктор и копирующее присваивание.**
---
### Деструктор класса

**Деструктор** - освобождает память выделенную (new) для объектов класса, при выходе за пределы видимости объекта.

**Синтаксис:**
```c++
~T() { // операции освобождения памяти от элементов класса T}
```
Пример:
```c++
class X {
	int i;
	X() :i{new int} {} // конструктор класса X
	~X() { delete i; } // деструктор класса X
	};
int main() {
 	for(int i=0; i<1; ++i)
	{
		X y;
	} // вызов деструктора класса X для объекта y
	return 0;
}
```
---

### Копирующий конструктор класса (C++11)

**Копирующий конструктор** - вызывается при инициализации объекта другим объектом одного типа.

**Синтаксис:** 
```c++
T::T(const T& a) {
	// код копирования
}
```
Пример:
```c++
class SomeClass
{  
    int i;
public:
    SomeClass(int ii) :i(ii) { } //  конструктор
    SomeClass(const SomeClass &obj)
    {      
        cout << "Конструктор копирования\n";
    }
};
int main()
{
    SomeClass obj1{1}; // создаем объект класса
    SomeClass obj2 = obj1;  // вызывается копирующий конструктор
}
```
---
### Копирующее присваивание (C++11)
**Копирующее присваивание** - вызывается при вызывается при присваивании объектов одного типа друг другу.

**Синтаксис**:

```c++
T& T::operator=(const T& a) {
	// выделение памяти (new) для нового значения
	// копирование нового значения
	// удаление старого значения (delete)
	return  *this // возврат указателя на себя
}
```
Пример:
```c++
string s = "World";
srting s2 = "!";
s2 = s; // вызывается копирующее присваивание
```
---

### Перемещающие операции (С++11)

**Перемещающий конструктор** - вызывается при инициализации оного объекта другим объектом такого же типа, возвращаемым в качестве результата выполнения функциии, не явно компилятором.

**Синтаксис**:
```c++
T::T(T&& a) : // копирование данных при инициализации
{
	// Обнуление объекта a
}
```
&& - означает ссылка на rvalue

**Перемещающее присваивание** - вызывается при присвоении одного объекта другим объектом того же типа, возвращаемым в качестве результата выполнения функции, не явно компилятором.

**Синтаксис:**
```c++
T& T::operator=(T&& a) {
	// операции освобождения памяти и копирования данных
	return *this; // возврат ссылки на себя
}
```

Пример:

```c++
class vector {
int sz;
double* elem;
public:
// Перемещающий конструктор
	vector(vector&& a) :sz{a.sz}, elem{a.elem} // копируем elem и sz из a
	{
		a.sz = 0;	// делаем вектор a пустым
		a.elem = nullptr;
	}
// Перемещающее присваивание
	vector& vector::operator=(vector&& a) {
		delete[] elem;	// освобождение старой памяти
		elem = a.elem;	// копирование elem
		sz = a.sz	// копирование sz
		a.sz = 0	// обнуляем вектор а
		a.elem = nullptr;
		return *this	// вотврат ссылки на себя
	}
... // остальные функции класса
};

vector fill(istream& is) { // заполняет вектор res значениями из потока is
	vector res;
	for (double x; is>>x; ) res.push_back(x);
	return res;
}

int main() {
	vector vec = fill(cin); // вызов перемещающего конструктора
	vector vec2 = {1,2,3};
	vec2 = fill(vec); // вызов перемещающего присваивания
	return 0;
}
```


---

### explicit
**explicit - (явный)** - модификатор запрещающий не явные преобразования.

Пример:
```c++
class T {
	explicit T () { } // конструктор запрещает неявные преобразования типов в тип T
};
```
---

