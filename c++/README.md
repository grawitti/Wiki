# C++ Wiki

## Типы данных:
* **bool** - true или false
* **char** - символ любой
* **int** - целочисленное значение
* **double** - число с плавоющей точкой
* **float** - число с плавующей точкой
* **string** - строка символов
* **vector`<T>`** - вектор объектов типа T
* **auto** - автоматичекий не тип

---
### auto
* Выводит тип объявленной переменной из выражения инициализации. _(C++11)_  
* Ключевое слово `auto` указывает компилятору использовать выражение инициализации объявленной переменной,или параметр лямбда-выражения, чтобы вывести ее тип.

>Ключевое слово auto рекомендуется использовать в большинстве ситуаций (кроме тех, когда требуется преобразование).

>Ключевое слово auto является местозаполнителем для типа, однако само по себе не означает тип. 

>Таким образом ключевое слово auto не может использоваться в приведениях типов или в таких операторах, как sizeof и typeid.  

Пример:
```c++
auto i;
i = 10; // integer
auto s;
s = "Hello"; // string
```
---

## Стандартная библиотека std
### Возвращение функцией нескольких значений (результатов) `std::tuple, std:tie` _(C++11)_

Пример:

```c++
tuple<int,string> f(void)
{
	return {485, "Hello";}
}
int main (void) 
{
	int a;
	string b;
	tie(a,b) = f();
}
```
---
## Инструкции

### Цикл прохода по списку fore _(C++11)_

Пример:
```c++
string s = "Hello";
for (auto e& : s) e = "x"; // изменяем исходные данные
for (auto e : s) cout << e; // не меняем исходные данные
```
---

### Лямбда выражения

**Лямбда-выражение** - неименованная функция (или просто лямбда) в _C++11_ — это удобный способ определения анонимного объекта-функции непосредственно в месте его вызова или передачи в функцию в качестве аргумента.

#### Синтаксис:

* [ capture ] ( params ) mutable exception attribute -> ret { body }
* [ capture ] ( params ) -> ret { body }
* [ capture ] ( params ) { body }
* [ capture ] { body }

1) Полное объявление

2) Объявление константной лямбды: объекты, захваченные копированием, не могут быть изменены.

3) Опущен возвращаемый тип в конце: возвращаемый тип замыкания operator() выводится в соответствии со следующими правилами:  
если body состоит из одного оператора return, то возвращаемый тип является типом возвращаемого выражения   (после неявного преобразования rvalue к lvalue, массива к указателю, или функции к указателю)  
В противном случае возвращаемый тип void  

4) Пропущен список параметров: функция не принимает аргументов, как если бы список параметров был ()

где:

* **mutable**	—	позволяет body изменять параметры, захваченные копированием, и вызывать их неконстантные функции-члены  
* **exception**	—	обеспечивает спецификацию исключения или опцию noexcept для оператора () типа-замыкания  
* **attribute**	—	обеспечивает спецификацию атрибута для оператора () типа замыкания  
* **capture**	—	определяет, какие символы, видимые в области объявления функции, ​​будут видны внутри тела функции.  
Список символов может быть передан следующим образом:  

  - [a,&b] где `a` захвачена по значению, а `b` захвачена по ссылке.
  - [this] захватывает указатель `this` по значению.
  - [&] захват всех символов по ссылке
  - [=] захват всех символов по значению
  - [] ничего не захватывает

* **params** —  Список параметров, как в объявлении функции
* **ret**	—	Возвращаемый тип. Если нет, то он выводится из возвращаемого значения (или void, если функция не возвращает никакого значения)

Пример:
```c++
char f ([](double d) { return d*d }, char c, int i)
{
	if(d <= i) return  c;
	else return 'N';
};
```
---
## Классы

### Правила реализации хороших классов:
* Если был захвачен ресурс **(new)** или какие-то члены класса **указаткли**, то должен быть **деструктор класса**.
* Если класс имеет **деструктор**, то скорее всего он должен иметь **копирующий конструктор и копирующее присваивание.**
---
### Деструктор класса

**Деструктор** - освобождает память выделенную (new) для объектов класса, при выходе за пределы видимости объекта.

**Синтаксис:**
```c++
~T() { // операции освобождения памяти от элементов класса T}
```
Пример:
```c++
class X {
	int i;
	X() :i{new int} {} // конструктор класса X
	~X() { delete i; } // деструктор класса X
	};
int main {
 	for(int i=0; i<1; ++i)
	{
		X y;
	} // вызов деструктора класса X для объекта y
	return 0;
}
```
---

### Копирующий конструктор класса (C++11)

**Копирующий конструктор** - вызывается при инициализации объекта другим объектом одного типа.

**Синтаксис:** 
```c++
T::T(const T& a) {
	// код копирования
}
```
Пример:
```c++
class SomeClass
{  
    int i;
public:
    SomeClass(int ii) :i(ii) { } //  конструктор
    SomeClass(const SomeClass &obj)
    {      
        cout << "Конструктор копирования\n";
    }
};
int main()
{
    SomeClass obj1{1}; // создаем объект класса
    SomeClass obj2 = obj1;  // вызывается копирующий конструктор
}
```
---
### Копирующее присваивание (C++11)
**Копирующее присваивание** - вызывается при вызывается при присваивании объектов одного типа друг другу.

**Синтаксис**:

```c++
T& T::operator=(const T& a) {
	// выделение памяти (new) для нового значения
	// копирование нового значения
	// удаление старого значения (delete)
	return  *this // возврат указателя на себя
}
```
Пример:
```c++
string s = "World";
srting s2 = "!";
s2 = s; // вызывается копирующее присваивание
```
---

### Перемещающие операции (С++11)

**Перемещающий конструктор** - вызывается при инициализации оного объекта другим объектом такого же типа, возвращаемым в качестве результата выполнения функциии, не явно компилятором.

**Синтаксис**:
```c++
T::T(T&& a) : // копирование данных при инициализации
{
	// Обнуление объекта a
}
```
&& - означает ссылка на rvalue

**Перемещающее присваивание** - вызывается при присвоении одного объекта другим объектом того же типа, возвращаемым в качестве результата выполнения функции, не явно компилятором.

**Синтаксис:**
```c++
T& T::operator=(T&& a) {
	// операции освобождения памяти и копирования данных
	return *this; // возврат ссылки на себя
}
```

Пример:

```c++
class vector {
int sz;
double* elem;
public:
// Перемещающий конструктор
	vector(vector&& a) :sz{a.sz}, elem{a.elem} // копируем elem и sz из a
	{
		a.sz = 0;	// делаем вектор a пустым
		a.elem = nullptr;
	}
// Перемещающее присваивание
	vector& vector::operator=(vector&& a) {
		delete[] elem;	// освобождение старой памяти
		elem = a.elem;	// копирование elem
		sz = a.sz	// копирование sz
		a.sz = 0	// обнуляем вектор а
		a.elem = nullptr;
		return *this	// вотврат ссылки на себя
	}
... // остальные функции класса
};

vector fill(istream& is) { // заполняет вектор res значениями из потока is
	vector res;
	for (double x; is>>x; ) res.push_back(x);
	return res;
}

int main {
	vector vec = fill(cin); // вызов перемещающего конструктора
	vector vec2 = {1,2,3};
	vec2 = fill(vec); // вызов перемещающего присваивания
	return 0;
}
```


---

### explicit
**explicit - (явный)** - модификатор запрещающий не явные преобразования.

Пример:
```c++
class T {
	explicit T () { } // конструктор запрещает неявные преобразования типов в тип T
};
```
---

